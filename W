-- ================================================================
-- BRAINROT FINDER v4 - Cross-Account Server Tracking via npoint.io
-- C·∫£i ti·∫øn: UI g·ªçn ƒë·∫πp, hop nhanh h∆°n, skip/kh√¥ng l∆∞u server full,
--           t·ª± ƒë·ªông d·ªçn cloud khi ƒë·∫ßy, discord embed g·ªçn ƒë·∫πp
-- ================================================================

-- ================================================================
-- GUARD
-- ================================================================
if shared.__BRAINROT_V4_ACTIVE then return end
shared.__BRAINROT_V4_ACTIVE = true

repeat task.wait() until game:IsLoaded()

-- ================================================================
-- SERVICES
-- ================================================================
local Players         = game:GetService("Players")
local TeleportService = game:GetService("TeleportService")
local HttpService     = game:GetService("HttpService")
local TweenService    = game:GetService("TweenService")
local Workspace       = game:GetService("Workspace")

local player   = Players.LocalPlayer
local placeId  = game.PlaceId
local jobId    = game.JobId

-- ================================================================
-- CONFIG
-- ================================================================
local WEBHOOK_URL    = "https://discord.com/api/webhooks/1472498140409102462/Ijb7ppZ8IZVFbTz2mSySRr3M9487k60ysmNZ2NFm8KlozX41BunCspHfA06Je-4N1WBm"
local PRICE_LIMIT    = 5_000_000
local MAX_DISTANCE   = 5
local NPOINT_BIN_ID  = "2843ef326b7c0d6abe44"
local NPOINT_BASE    = "https://api.npoint.io/"

local MAX_CLOUD_SIZE = 300   -- t·ªëi ƒëa server l∆∞u trong cloud
local TRIM_TO        = 150   -- khi ƒë·∫ßy, gi·ªØ l·∫°i bao nhi√™u server m·ªõi nh·∫•t
local HOP_WAIT       = 0.4   -- gi√¢y ch·ªù gi·ªØa c√°c hop (gi·∫£m t·ª´ 0.8+1.5)
local SERVER_LIMIT   = 8     -- max player c·ªßa game (ƒë·ªÉ check server full)

-- ================================================================
-- UI ‚Äî Compact, clean, kh√¥ng lag
-- ================================================================
local playerGui = player:WaitForChild("PlayerGui")

-- X√≥a UI c≈© n·∫øu c√≥
local old = playerGui:FindFirstChild("BrainrotUI")
if old then old:Destroy() end

local screenGui = Instance.new("ScreenGui")
screenGui.Name            = "BrainrotUI"
screenGui.ResetOnSpawn    = false
screenGui.DisplayOrder    = 999
screenGui.IgnoreGuiInset  = true
screenGui.Parent          = playerGui

-- Card nh·ªè g·ªçn g√≥c tr√™n tr√°i
local card = Instance.new("Frame")
card.Name                = "Card"
card.Size                = UDim2.new(0, 300, 0, 130)
card.Position            = UDim2.new(0, 14, 0, 14)
card.BackgroundColor3    = Color3.fromRGB(16, 16, 22)
card.BorderSizePixel     = 0
card.Parent              = screenGui
Instance.new("UICorner", card).CornerRadius = UDim.new(0, 10)

local stroke = Instance.new("UIStroke")
stroke.Color      = Color3.fromRGB(100, 60, 180)
stroke.Thickness  = 1.5
stroke.Transparency = 0.4
stroke.Parent     = card

-- Top accent line
local topBar = Instance.new("Frame")
topBar.Size              = UDim2.new(1, 0, 0, 3)
topBar.BackgroundColor3  = Color3.fromRGB(120, 60, 210)
topBar.BorderSizePixel   = 0
topBar.ZIndex            = 2
topBar.Parent            = card
Instance.new("UICorner", topBar).CornerRadius = UDim.new(0, 10)

local tg = Instance.new("UIGradient")
tg.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(90, 40, 200)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(200, 70, 160))
})
tg.Parent = topBar

-- Title
local titleLbl = Instance.new("TextLabel")
titleLbl.Size             = UDim2.new(1, -12, 0, 22)
titleLbl.Position         = UDim2.new(0, 10, 0, 10)
titleLbl.BackgroundTransparency = 1
titleLbl.Text             = "üß† Brainrot Finder v4"
titleLbl.TextColor3       = Color3.fromRGB(210, 190, 255)
titleLbl.Font             = Enum.Font.GothamBold
titleLbl.TextSize         = 13
titleLbl.TextXAlignment   = Enum.TextXAlignment.Left
titleLbl.Parent           = card

-- Divider
local div = Instance.new("Frame")
div.Size             = UDim2.new(1, -20, 0, 1)
div.Position         = UDim2.new(0, 10, 0, 36)
div.BackgroundColor3 = Color3.fromRGB(45, 38, 70)
div.BorderSizePixel  = 0
div.Parent           = card

-- Status line
local statusLbl = Instance.new("TextLabel")
statusLbl.Size             = UDim2.new(1, -12, 0, 20)
statusLbl.Position         = UDim2.new(0, 10, 0, 42)
statusLbl.BackgroundTransparency = 1
statusLbl.Text             = "‚è≥ ƒêang kh·ªüi ƒë·ªông..."
statusLbl.TextColor3       = Color3.fromRGB(180, 160, 240)
statusLbl.Font             = Enum.Font.GothamSemibold
statusLbl.TextSize         = 12
statusLbl.TextXAlignment   = Enum.TextXAlignment.Left
statusLbl.TextTruncate     = Enum.TextTruncate.AtEnd
statusLbl.Parent           = card

-- Info line
local infoLbl = Instance.new("TextLabel")
infoLbl.Size             = UDim2.new(1, -12, 0, 16)
infoLbl.Position         = UDim2.new(0, 10, 0, 64)
infoLbl.BackgroundTransparency = 1
infoLbl.Text             = ""
infoLbl.TextColor3       = Color3.fromRGB(110, 105, 145)
infoLbl.Font             = Enum.Font.Gotham
infoLbl.TextSize         = 11
infoLbl.TextXAlignment   = Enum.TextXAlignment.Left
infoLbl.TextTruncate     = Enum.TextTruncate.AtEnd
infoLbl.Parent           = card

-- Hop & cloud stat
local statLbl = Instance.new("TextLabel")
statLbl.Size             = UDim2.new(1, -12, 0, 16)
statLbl.Position         = UDim2.new(0, 10, 0, 82)
statLbl.BackgroundTransparency = 1
statLbl.Text             = "üîÅ Hop: 0   ‚òÅÔ∏è Cloud: 0"
statLbl.TextColor3       = Color3.fromRGB(100, 98, 140)
statLbl.Font             = Enum.Font.Gotham
statLbl.TextSize         = 11
statLbl.TextXAlignment   = Enum.TextXAlignment.Left
statLbl.Parent           = card

-- Progress bar (m·ªèng, g·ªçn)
local pBg = Instance.new("Frame")
pBg.Size             = UDim2.new(1, -20, 0, 4)
pBg.Position         = UDim2.new(0, 10, 0, 114)
pBg.BackgroundColor3 = Color3.fromRGB(30, 26, 46)
pBg.BorderSizePixel  = 0
pBg.Parent           = card
Instance.new("UICorner", pBg).CornerRadius = UDim.new(1, 0)

local pBar = Instance.new("Frame")
pBar.Size             = UDim2.new(0, 0, 1, 0)
pBar.BackgroundColor3 = Color3.fromRGB(120, 60, 210)
pBar.BorderSizePixel  = 0
pBar.Parent           = pBg
Instance.new("UICorner", pBar).CornerRadius = UDim.new(1, 0)

local pbg2 = Instance.new("UIGradient")
pbg2.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(90, 40, 200)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(200, 70, 160))
})
pbg2.Parent = pBar

-- Pulse nh·∫π ‚Äî ch·ªâ 1 coroutine ƒë∆°n gi·∫£n, kh√¥ng lag
task.spawn(function()
    local t = 0
    while card and card.Parent do
        t += 0.06
        stroke.Transparency = 0.35 + math.sin(t) * 0.2
        task.wait(0.08) -- 12fps thay v√¨ 20fps ‚Üí ti·∫øt ki·ªám h∆°n
    end
end)

-- Helper UI
local function setStatus(icon, msg, col)
    statusLbl.Text      = icon .. " " .. msg
    statusLbl.TextColor3 = col or Color3.fromRGB(180, 160, 240)
end

local function setInfo(msg)
    infoLbl.Text = msg
end

local function setProgress(p)
    local tw = TweenService:Create(pBar,
        TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
        { Size = UDim2.new(math.clamp(p, 0, 1), 0, 1, 0) }
    )
    tw:Play()
end

local hopCount   = 0
local cloudCount = 0

local function updateStat()
    statLbl.Text = string.format("üîÅ Hop: %d   ‚òÅÔ∏è Cloud: %d", hopCount, cloudCount)
end

-- ================================================================
-- CLOUD I/O
-- ================================================================
local function cloudRead()
    local ok, raw = pcall(game.HttpGet, game, NPOINT_BASE .. NPOINT_BIN_ID)
    if not ok or not raw then return nil end
    local ok2, data = pcall(HttpService.JSONDecode, HttpService, raw)
    if ok2 and data and data.visited then
        cloudCount = #data.visited
        updateStat()
        return data.visited
    end
    return nil
end

local function cloudWrite(list)
    -- T·ª± ƒë·ªông d·ªçn khi v∆∞·ª£t gi·ªõi h·∫°n
    if #list > MAX_CLOUD_SIZE then
        local trimmed = {}
        for i = #list - TRIM_TO + 1, #list do
            table.insert(trimmed, list[i])
        end
        list = trimmed
        setInfo("‚ôªÔ∏è Cloud ƒë·∫ßy ‚Üí ƒë√£ t·ª± d·ªçn, gi·ªØ " .. #list .. " server")
    end

    local body = HttpService:JSONEncode({ visited = list })
    local req  = (syn and syn.request) or http_request or (http and http.request) or request
    if not req then return false, list end

    local ok = pcall(function()
        req({
            Url     = NPOINT_BASE .. NPOINT_BIN_ID,
            Method  = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body    = body,
        })
    end)

    cloudCount = #list
    updateStat()
    return ok, list
end

-- ================================================================
-- SCAN
-- ================================================================
local function parseGeneration(text)
    if not text then return 0 end
    local num = tonumber(text:match("[%d%.]+")) or 0
    if text:find("K") then num *= 1e3
    elseif text:find("M") then num *= 1e6 end
    return num
end

local function getInstanceWorldPos(inst)
    if inst:IsA("BasePart") then return inst.Position end
    if inst:IsA("Model") then
        return inst.PrimaryPart and inst.PrimaryPart.Position
            or inst:GetPivot().Position
    end
end

local function getBaseNameFromPlot(plot)
    local sign = plot:FindFirstChild("PlotSign")
        and plot.PlotSign:FindFirstChild("SurfaceGui")
        and plot.PlotSign.SurfaceGui:FindFirstChild("Frame")
        and plot.PlotSign.SurfaceGui.Frame:FindFirstChild("TextLabel")
    return sign and sign.Text or "Unknown Base"
end

local function collectBrainrot()
    local found  = {}
    local plots  = Workspace:FindFirstChild("Plots")
    local debris = Workspace:FindFirstChild("Debris")
    if not plots or not debris then return found end

    local plotList = plots:GetChildren()
    for idx, plot in ipairs(plotList) do
        setProgress(idx / #plotList)
        setInfo(string.format("üîç Scan %d/%d plots", idx, #plotList))

        local baseName = getBaseNameFromPlot(plot)
        local podiums  = plot:FindFirstChild("AnimalPodiums")
        if not podiums then continue end

        for _, podium in ipairs(podiums:GetChildren()) do
            local att = podium:FindFirstChild("Base")
                and podium.Base:FindFirstChild("Spawn")
                and podium.Base.Spawn:FindFirstChild("Attachment")
            if not att then continue end

            local attPos = att.WorldPosition
            local nearest, nearestDist

            for _, d in ipairs(debris:GetChildren()) do
                local oh   = d:FindFirstChild("AnimalOverhead")
                if not oh then continue end
                local nLbl = oh:FindFirstChild("DisplayName")
                local gLbl = oh:FindFirstChild("Generation")
                if not nLbl or not gLbl then continue end
                local pos  = getInstanceWorldPos(d)
                if not pos then continue end
                local dist = (pos - attPos).Magnitude
                if dist <= MAX_DISTANCE and (not nearestDist or dist < nearestDist) then
                    nearestDist = dist
                    nearest = {
                        name     = nLbl.Text,
                        genText  = gLbl.Text,
                        genValue = parseGeneration(gLbl.Text),
                        baseName = baseName,
                    }
                end
            end

            if nearest and nearest.genValue >= PRICE_LIMIT then
                table.insert(found, nearest)
            end
        end
        task.wait()
    end
    return found
end

-- ================================================================
-- WEBHOOK ‚Äî Compact, clean Discord embed
-- ================================================================
local function sendWebhook(loot)
    if #loot == 0 then return end

    local link = ("https://kebabman.vercel.app/start?placeId=%s&gameInstanceId=%s")
        :format(placeId, tostring(jobId))

    -- G·ªôp loot v√†o 1 field g·ªçn
    local lines = {}
    for _, item in ipairs(loot) do
        table.insert(lines, string.format("`%s` %s ‚Äî %s", item.genText, item.name, item.baseName))
    end

    local playerCount = #Players:GetPlayers()

    local payload = {
        content = "@everyone",
        embeds  = {{
            title       = string.format("üß† %d Brainrot Found!", #loot),
            url         = link,
            description = string.format(
                "**[üöÄ Join Server](%s)**\n```\n%s\n```",
                link, table.concat(lines, "\n")
            ),
            color  = 0x7C3AED,
            fields = {
                {
                    name   = "Server",
                    value  = string.format("üë• `%d/%d`  ‚Ä¢  üåê `%s`", playerCount, SERVER_LIMIT, tostring(placeId)),
                    inline = false,
                },
                {
                    name   = "Job ID",
                    value  = "`" .. tostring(jobId):sub(1, 22) .. "...`",
                    inline = false,
                },
            },
            footer    = { text = "Brainrot Finder v4" },
            timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
        }}
    }

    local req = (syn and syn.request) or http_request or (http and http.request) or request
    if req then
        pcall(function()
            req({
                Url     = WEBHOOK_URL,
                Method  = "POST",
                Headers = { ["Content-Type"] = "application/json" },
                Body    = HttpService:JSONEncode(payload),
            })
        end)
    end
end

-- ================================================================
-- CHECK: Server c√≥ full kh√¥ng?
-- ================================================================
local function isCurrentServerFull()
    return #Players:GetPlayers() >= SERVER_LIMIT
end

local function isServerFull(serverData)
    return (tonumber(serverData.playing) or 0) >= (tonumber(serverData.maxPlayers) or SERVER_LIMIT)
end

-- ================================================================
-- SCAN & WEBHOOK (run once on join)
-- ================================================================
setStatus("‚è≥", "ƒêang scan...", Color3.fromRGB(180, 160, 240))
setProgress(0)

-- N·∫øu server hi·ªán t·∫°i full ‚Üí kh√¥ng l∆∞u, hop ngay
if isCurrentServerFull() then
    setStatus("‚ö°", "Server full ‚Üí b·ªè qua, hop ngay", Color3.fromRGB(220, 160, 60))
    setInfo("Server ƒë·∫ßy, kh√¥ng l∆∞u cloud")
else
    local loot = collectBrainrot()
    setProgress(1)

    if #loot == 0 then
        setStatus("üòû", "Kh√¥ng th·∫•y brainrot", Color3.fromRGB(180, 100, 100))
        stroke.Color = Color3.fromRGB(160, 50, 50)
    else
        setStatus("‚úÖ", string.format("Webhook g·ª≠i! (%d found)", #loot), Color3.fromRGB(80, 210, 130))
        stroke.Color = Color3.fromRGB(60, 190, 100)
        pBar.BackgroundColor3 = Color3.fromRGB(60, 190, 100)
        sendWebhook(loot)
    end
end

-- ================================================================
-- SERVER HOP ‚Äî Nhanh, th√¥ng minh, ƒë·ªìng b·ªô cloud
-- ================================================================
local function serverHop()
    hopCount += 1
    setStatus("üîÅ", string.format("Hopping #%d...", hopCount), Color3.fromRGB(140, 140, 220))
    setInfo("‚òÅÔ∏è ƒê·ªçc cloud...")

    -- ƒê·ªçc danh s√°ch ƒë√£ hop t·ª´ cloud
    local visitedList = cloudRead() or {}

    -- N·∫øu server hi·ªán t·∫°i KH√îNG full ‚Üí th√™m v√†o cloud
    if not isCurrentServerFull() and not table.find(visitedList, jobId) then
        table.insert(visitedList, jobId)
    else
        setInfo("‚ö†Ô∏è Server hi·ªán t·∫°i full ‚Üí kh√¥ng l∆∞u cloud")
    end

    setInfo("üåê L·∫•y server list...")

    -- L·∫•y candidates t·ª´ Roblox (c·∫£ Asc l·∫´n Desc ƒë·ªÉ c√≥ nhi·ªÅu server)
    local candidates = {}
    for _, sort in ipairs({ "Asc", "Desc" }) do
        local ok, raw = pcall(game.HttpGet, game,
            "https://games.roblox.com/v1/games/" .. placeId ..
            "/servers/Public?sortOrder=" .. sort .. "&limit=100&excludeFullGames=true"
        )
        if ok and raw then
            local ok2, body = pcall(HttpService.JSONDecode, HttpService, raw)
            if ok2 and body and body.data then
                for _, v in ipairs(body.data) do
                    if  type(v) == "table"
                    and v.id
                    and v.id ~= jobId
                    and not isServerFull(v)               -- double-check kh√¥ng full
                    and not table.find(visitedList, v.id)
                    and not table.find(candidates, v.id)
                    then
                        table.insert(candidates, v.id)
                    end
                end
            end
        end
    end

    -- H·∫øt server m·ªõi ‚Üí trim cloud r·ªìi th·ª≠ l·∫°i
    if #candidates == 0 then
        setStatus("‚ôªÔ∏è", "H·∫øt server m·ªõi, reset...", Color3.fromRGB(220, 160, 60))
        setInfo("Gi·ªØ l·∫°i " .. TRIM_TO .. " server g·∫ßn nh·∫•t")

        if #visitedList > TRIM_TO then
            local trimmed = {}
            for i = #visitedList - TRIM_TO + 1, #visitedList do
                table.insert(trimmed, visitedList[i])
            end
            visitedList = trimmed
        else
            visitedList = { jobId }
        end

        cloudWrite(visitedList)
        task.wait(4)
        return
    end

    -- Ch·ªçn server ng·∫´u nhi√™n t·ª´ candidates
    local chosen = candidates[math.random(1, #candidates)]

    -- Ghi cloud TR∆Ø·ªöC khi teleport
    table.insert(visitedList, chosen)
    local _, newList = cloudWrite(visitedList)
    visitedList = newList

    setInfo(string.format("üöÄ Hop ‚Üí server m·ªõi  (%d ·ª©ng vi√™n)", #candidates))
    updateStat()

    task.wait(HOP_WAIT)
    TeleportService:TeleportToPlaceInstance(placeId, chosen, player)
end

-- ================================================================
-- MAIN LOOP
-- ================================================================
task.wait(1)
while true do
    local ok, err = pcall(serverHop)
    if not ok then
        setStatus("‚ö†Ô∏è", "L·ªói: " .. tostring(err):sub(1, 40), Color3.fromRGB(220, 160, 60))
        task.wait(3)
    end
    task.wait(0.5)
end
